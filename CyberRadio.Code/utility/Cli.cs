using AetherUtils.Core.Logging;
using System.Diagnostics;

namespace RadioExt_Helper.utility;

/// <summary>
/// Handles running the low-level CLI commands for WolvenKit and generate-inkatlas.exe. Has events for streaming output and error messages generated by the CLI.
/// </summary>
public class Cli(string executablePath)
{
    /// <summary>
    /// Occurs when the output stream from the CLI changes.
    /// </summary>
    public event EventHandler<string?>? OutputChanged;

    /// <summary>
    /// Occurs when the error stream from the CLI changes.
    /// </summary>
    public event EventHandler<string?>? ErrorChanged;

    private readonly string _executableName = Path.GetFileName(executablePath);

    #region generate-inkatlas.exe
    /// <summary>
    /// Generate an .inkatlas file from a folder of images.
    /// </summary>
    /// <param name="iconFolderPath">The path to the folder containing the <c>.png</c> files.</param>
    /// <param name="outputFolderPath">The output path the final <c>.inkatlas.json</c> file should be saved.</param>
    /// <param name="atlasName">The name of the atlas to generate.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    /// <remarks>
    ///     The <c>generate_inkatlas.exe</c> is a tool that generates an <c>.inkatlas.json</c> file from a folder of <c>.png</c> files.
    ///     It was built from a modified version of the original <see href="https://github.com/DoctorPresto/Cyberpunk-Helper-Scripts/blob/main/generate_inkatlas.py">generate_inkatlas.py</see> script and allows for command line arguments to be passed in.
    ///     The modified tool is embedded as a resource in this project and is extracted to a temporary location before being executed.
    /// </remarks>
    public async Task GenerateInkAtlasJsonAsync(string iconFolderPath, string outputFolderPath, string atlasName)
    {
        var arguments = $"\"{iconFolderPath}\" \"{outputFolderPath}\" \"{atlasName}\"";
        await ExecuteCommandAsync(arguments);
    }
    #endregion

    #region WolvenKit CLI

    /// <summary>
    /// Convert a <c>.inkatlas.json</c> file to a <c>.inkatlas</c> file.
    /// </summary>
    /// <param name="inkAtlasJsonPath">The full path to the <c>.inkatlas.json</c> file.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public async Task ConvertToInkAtlasFile(string inkAtlasJsonPath)
    {
        var arguments = $"convert deserialize \"{inkAtlasJsonPath}\"";
        await ExecuteCommandAsync(arguments);
    }

    /// <summary>
    /// Import a folder of raw files to a WolvenKit faux project.
    /// </summary>
    /// <param name="sourcePath">The full path to the raw input files.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public async Task ImportToWolvenKitProject(string sourcePath)
    {
        var arguments = $"import -p \"{sourcePath}\"";
        await ExecuteCommandAsync(arguments);
    }

    /// <summary>
    /// Pack (compress) the contents of a directory into a <c>.archive</c> file. This essentially "builds" the faux mod.
    /// </summary>
    /// <param name="modPath">The path to a faux mod directory.</param>
    /// <param name="outputFolder">The output folder to store the packed <c>.archive</c> file in.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public async Task PackArchive(string modPath, string outputFolder)
    {
        var arguments = $"pack -p \"{modPath}\" -o \"{outputFolder}\"";
        await ExecuteCommandAsync(arguments);
    }

    /// <summary>
    /// Unpack (extract) a <c>.archive</c> file to the specified output folder.
    /// </summary>
    /// <param name="archivePath">The full path to the <c>.archive</c> file.</param>
    /// <param name="outputFolder">The output folder to store the extracted contents in.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public async Task UnpackArchive(string archivePath, string outputFolder)
    {
        var arguments = $"unbundle -p \"{archivePath}\" -o \"{outputFolder}\"";
        await ExecuteCommandAsync(arguments);
    }

    /// <summary>
    /// Export an <c>.xbm</c> file to a <c>.png</c> file.
    /// </summary>
    /// <param name="modPath">The path to the folder containing the <c>.xbm</c> files to export.</param>
    /// <param name="outputFolder">The output folder to store the exported <c>.png</c> files.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public async Task ExportPng(string modPath, string outputFolder)
    {
        var arguments = $"export --uext png -p \"{modPath}\" -o \"{outputFolder}\"";
        await ExecuteCommandAsync(arguments);
    }

    #endregion

    /// <summary>
    /// Executes a CLI command asynchronously. All output and error streams are redirected to events.
    /// </summary>
    /// <param name="arguments">The arguments to run the command with.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    private async Task ExecuteCommandAsync(string arguments)
    {
        try
        {
            var processInfo = new ProcessStartInfo(executablePath, arguments)
            {
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            using var process = new Process();
            process.StartInfo = processInfo;
            process.OutputDataReceived += (_, e) => OnOutputChanged(e.Data);
            process.ErrorDataReceived += (_, e) => OnErrorChanged(e.Data);

            process.Start();

            process.BeginOutputReadLine();
            process.BeginErrorReadLine();

            await process.WaitForExitAsync();
        }
        catch (Exception ex)
        {
            AuLogger.GetCurrentLogger<Cli>("ExecuteCommand").Error(ex);
        }
    }

    private void OnOutputChanged(string? output)
    {
        if (string.IsNullOrEmpty(output)) return;

        OutputChanged?.Invoke(this, output);
        AuLogger.GetCurrentLogger<Cli>("ExecuteCommand").Info(output);
    }

    private void OnErrorChanged(string? error)
    {
        if (string.IsNullOrEmpty(error)) return;

        ErrorChanged?.Invoke(this, error);
        AuLogger.GetCurrentLogger<Cli>("ExecuteCommand").Error(error);
    }
}